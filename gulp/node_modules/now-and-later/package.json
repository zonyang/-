{
  "_args": [
    [
      {
        "raw": "now-and-later@^2.0.0",
        "scope": null,
        "escapedName": "now-and-later",
        "name": "now-and-later",
        "rawSpec": "^2.0.0",
        "spec": ">=2.0.0 <3.0.0",
        "type": "range"
      },
      "C:\\gulp\\node_modules\\bach"
    ]
  ],
  "_from": "now-and-later@>=2.0.0 <3.0.0",
  "_id": "now-and-later@2.0.0",
  "_inCache": true,
  "_location": "/now-and-later",
  "_nodeVersion": "0.10.41",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/now-and-later-2.0.0.tgz_1497714939409_0.8014816557988524"
  },
  "_npmUser": {
    "name": "phated",
    "email": "blaine.bublitz@gmail.com"
  },
  "_npmVersion": "2.15.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "now-and-later@^2.0.0",
    "scope": null,
    "escapedName": "now-and-later",
    "name": "now-and-later",
    "rawSpec": "^2.0.0",
    "spec": ">=2.0.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/bach",
    "/vinyl-sourcemap"
  ],
  "_resolved": "https://registry.npmjs.org/now-and-later/-/now-and-later-2.0.0.tgz",
  "_shasum": "bc61cbb456d79cb32207ce47ca05136ff2e7d6ee",
  "_shrinkwrap": null,
  "_spec": "now-and-later@^2.0.0",
  "_where": "C:\\gulp\\node_modules\\bach",
  "author": {
    "name": "Gulp Team",
    "email": "team@gulpjs.com",
    "url": "http://gulpjs.com/"
  },
  "bugs": {
    "url": "https://github.com/gulpjs/now-and-later/issues"
  },
  "contributors": [
    {
      "name": "Blaine Bublitz",
      "email": "blaine.bublitz@gmail.com"
    }
  ],
  "dependencies": {
    "once": "^1.3.2"
  },
  "description": "Map over an array or object of values in parallel or series, passing each through the async iterator, with optional lifecycle hooks.",
  "devDependencies": {
    "eslint": "^1.7.3",
    "eslint-config-gulp": "^2.0.0",
    "expect": "^1.19.0",
    "istanbul": "^0.4.3",
    "istanbul-coveralls": "^1.0.3",
    "jscs": "^2.3.5",
    "jscs-preset-gulp": "^1.0.0",
    "mocha": "^2.4.5"
  },
  "directories": {},
  "dist": {
    "shasum": "bc61cbb456d79cb32207ce47ca05136ff2e7d6ee",
    "tarball": "https://registry.npmjs.org/now-and-later/-/now-and-later-2.0.0.tgz"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "files": [
    "index.js",
    "lib",
    "LICENSE"
  ],
  "gitHead": "771bb1509957b013f35852d94a26c4fa5e963e2a",
  "homepage": "https://github.com/gulpjs/now-and-later#readme",
  "keywords": [
    "async",
    "async.js",
    "map",
    "control",
    "flow",
    "extension",
    "tracing",
    "debug",
    "aop",
    "aspect",
    "timing",
    "tracing"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "phated",
      "email": "blaine@iceddev.com"
    }
  ],
  "name": "now-and-later",
  "optionalDependencies": {},
  "readme": "<p align=\"center\">\n  <a href=\"http://gulpjs.com\">\n    <img height=\"257\" width=\"114\" src=\"https://raw.githubusercontent.com/gulpjs/artwork/master/gulp-2x.png\">\n  </a>\n</p>\n\n# now-and-later\n\n[![NPM version][npm-image]][npm-url] [![Downloads][downloads-image]][npm-url] [![Build Status][travis-image]][travis-url] [![AppVeyor Build Status][appveyor-image]][appveyor-url] [![Coveralls Status][coveralls-image]][coveralls-url] [![Gitter chat][gitter-image]][gitter-url]\n\nMap over an array or object of values in parallel or series, passing each through the async iterator, with optional lifecycle hooks.\n\n## Usage\n\n```js\nvar nal = require('now-and-later');\n\nfunction iterator(value, key, cb){\n  // called with each value in sequence\n  // also passes the key\n  cb(null, value * 2)\n}\n\nfunction create(value, key){\n  // called at the beginning of every iteration\n  // return a storage object to be passed to each lifecycle method\n  return { key: key, value: value };\n}\n\nfunction before(storage){\n  // called before the iterator function of every iteration\n  // receives the storage returned from `create`\n}\n\nfunction after(result, storage){\n  // called after a success occurs in the iterator function of any iteration\n  // receives the `result` of the iterator and the storage returned from `create`\n}\n\nfunction error(error, storage){\n  // called after an error occurs in the iterator function of any iteration\n  // receives the `error` of the iterator and the storage returned from `create`\n}\n\nfunction done(error, results) {\n  // called after all iterations complete or an error occurs in an iterator\n  // receives an `error` if one occurred and all results (or partial results upon error) of the iterators\n}\n\n/*\n  Calling mapSeries with an object can't guarantee order\n  It uses Object.keys to get an order\n  It is better to use an array if order must be guaranteed\n */\nnal.mapSeries([1, 2, 3], iterator, {\n  create: create,\n  before: before,\n  after: after,\n  error: error\n}, done);\n\nnal.map({\n  iter1: 1,\n  iter2: 2\n}, iterator, {\n  create: create,\n  before: before,\n  after: after,\n  error: error\n}, done);\n```\n\n## API\n\n### `map(values, iterator[, extensions][, callback])`\n\nTakes an object or array of `values` and an `iterator` function to execute with each value.\nOptionally, takes an `extensions` object and a `callback` function that is called upon completion of the iterations.\n\nAll iterations run in parallel.\n\n#### `values`\n\nAn array or object of values to iterate over.\n\nIf `values` is an array, iterations are started in order by index. If `values` is an object, iterations are started in order by the order returned by `Object.keys` (order is not guaranteed).\n\nIf `values` is an array, the results of each iteration will be mapped to an array. If `values` is an object, the results of each iteration will be mapped to an object with corresponding keys.\n\n#### `iterator(value, key, done)`\n\nAn async function called per iteration. All iterations are run in parallel.\n\nThe `iterator` function is called once with each `value`, `key` and a function (`done(error, result)`) to call when the async work is complete.\n\nIf `done` is passed an error as the first argument, the iteration will fail and the sequence will be ended; however, any iterations in progress will still complete. If `done` is passed a `result` value as the second argument, it will be added to the final results array or object.\n\n#### `extensions`\n\nThe `extensions` object is used for specifying functions that give insight into the lifecycle of each iteration. The possible extension points are `create`, `before`, `after` and `error`. If an extension point is not specified, it defaults to a no-op function.\n\n##### `extensions.create(value, key)`\n\nCalled at the very beginning of each iteration with the `value` being iterated and the `key` from the array or object. If `create` returns a value (`storage`), it is passed to the `before`, `after` and `error` extension points.\n\nIf a value is not returned, an empty object is used as `storage` for each other extension point.\n\nThis is useful for tracking information across an iteration.\n\n##### `extensions.before(storage)`\n\nCalled immediately before each iteration with the `storage` value returned from the `create` extension point.\n\n##### `extensions.after(result, storage)`\n\nCalled immediately after each iteration with the `result` of the iteration and the `storage` value returned from the `create` extension point.\n\n##### `extensions.error(error, storage)`\n\nCalled immediately after a failed iteration with the `error` of the iteration and the `storage` value returned from the `create` extension point.\n\n#### `callback(error, results)`\n\nA function that is called after all iterations have completed or one iteration has errored.\n\nIf all iterations completed successfully, the `error` argument will be empty and the `results` will be a mapping of the `iterator` results.\n\nIf an iteration errored, the `error` argument will be passed from that iteration and the `results` will be whatever partial results had completed successfully before the error occurred.\n\n### `mapSeries(values, iterator[, extensions][, callback])`\n\nTakes an object or array of `values` and an `iterator` function to execute with each value.\nOptionally, takes an `extensions` object and a `callback` function that is called upon completion of the iterations.\n\nAll iterations run in serial.\n\n#### `values`\n\nAn array or object of values to iterate over.\n\nIf `values` is an array, iterations are started in order by index. If `values` is an object, iterations are started in order by the order returned by `Object.keys` (order is not guaranteed).\n\nIf `values` is an array, the results of each iteration will be mapped to an array. If `values` is an object, the results of each iteration will be mapped to an object with corresponding keys.\n\n#### `iterator(value, key, done)`\n\nAn async function called per iteration. All iterations are run in serial.\n\nThe `iterator` function is called once with each `value`, `key` and a function (`done(error, result)`) to call when the async work is complete.\n\nIf `done` is passed an error as the first argument, the iteration will fail and the sequence will be ended without executing any more iterations. If `done` is passed a `result` value as the second argument, it will be added to the final results array or object.\n\n#### `extensions`\n\nThe `extensions` object is used for specifying functions that give insight into the lifecycle of each iteration. The possible extension points are `create`, `before`, `after` and `error`. If an extension point is not specified, it defaults to a no-op function.\n\n##### `extensions.create(value, key)`\n\nCalled at the very beginning of each iteration with the `value` being iterated and the `key` from the array or object. If `create` returns a value (`storage`), it is passed to the `before`, `after` and `error` extension points.\n\nIf a value is not returned, an empty object is used as `storage` for each other extension point.\n\nThis is useful for tracking information across an iteration.\n\n##### `extensions.before(storage)`\n\nCalled immediately before each iteration with the `storage` value returned from the `create` extension point.\n\n##### `extensions.after(result, storage)`\n\nCalled immediately after each iteration with the `result` of the iteration and the `storage` value returned from the `create` extension point.\n\n##### `extensions.error(error, storage)`\n\nCalled immediately after a failed iteration with the `error` of the iteration and the `storage` value returned from the `create` extension point.\n\n#### `callback(error, results)`\n\nA function that is called after all iterations have completed or one iteration has errored.\n\nIf all iterations completed successfully, the `error` argument will be empty and the `results` will be a mapping of the `iterator` results.\n\nIf an iteration errored, the `error` argument will be passed from that iteration and the `results` will be whatever partial results had completed successfully before the error occurred.\n\n## License\n\nMIT\n\n[downloads-image]: http://img.shields.io/npm/dm/now-and-later.svg\n[npm-url]: https://www.npmjs.com/package/now-and-later\n[npm-image]: http://img.shields.io/npm/v/now-and-later.svg\n\n[travis-url]: https://travis-ci.org/gulpjs/now-and-later\n[travis-image]: http://img.shields.io/travis/gulpjs/now-and-later.svg?label=travis-ci\n\n[appveyor-url]: https://ci.appveyor.com/project/gulpjs/now-and-later\n[appveyor-image]: https://img.shields.io/appveyor/ci/gulpjs/now-and-later.svg?label=appveyor\n\n[coveralls-url]: https://coveralls.io/r/gulpjs/now-and-later\n[coveralls-image]: http://img.shields.io/coveralls/gulpjs/now-and-later/master.svg\n\n[gitter-url]: https://gitter.im/gulpjs/gulp\n[gitter-image]: https://badges.gitter.im/gulpjs/gulp.svg\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gulpjs/now-and-later.git"
  },
  "scripts": {
    "cover": "istanbul cover _mocha --report lcovonly",
    "coveralls": "npm run cover && istanbul-coveralls",
    "lint": "eslint . && jscs index.js lib/ test/",
    "pretest": "npm run lint",
    "test": "mocha --async-only"
  },
  "version": "2.0.0"
}
